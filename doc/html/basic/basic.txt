-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/basic#readme</a>
@package basic
@version 0.1.0.0

module Control.Monad.Trans.Counter

-- | Add a counter to <a>Monad</a>ic operations, where a count of
--   <tt>1</tt> is added for <a>fmap</a>, <tt>(<a>&lt;*&gt;</a>)</tt>, and
--   <tt>(<a>&gt;&gt;=</a>)</tt>
newtype CounterT m a
CounterT :: Int -> m (a, Int) -> CounterT m a
[unCounterT] :: CounterT m a -> Int -> m (a, Int)

-- | Initial count is <tt>0</tt>
runCounterT :: CounterT m a -> m (a, Int)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Counter.CounterT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Trans.Counter.CounterT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Counter.CounterT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Counter.CounterT

module Data.History.Stack

-- | A stack of effects
data HistoryStack f
PushHistory :: (f (HistoryStack f)) -> HistoryStack f
EmptyHistory :: HistoryStack f

-- | Hoist one <a>Functor</a> to another within a <a>HistoryStack</a>
hoistHistoryStack :: Functor g => (forall x. f x -> g x) -> HistoryStack f -> HistoryStack g

-- | Wrap a layer around a <a>HistoryStack</a>
wrapHistoryStack :: f (HistoryStack f) -> HistoryStack f

-- | Push a layer onto a <a>HistoryStack</a> (at the end, i.e. most recent)
pushHistory :: Functor f => f a -> HistoryStack f -> HistoryStack f

-- | A <a>HistoryStack</a> with a single layer of effects
singletonHistoryStack :: Functor f => f a -> HistoryStack f

-- | Infinite <a>HistoryStack</a> formed by repeating a single layer of
--   effects
foreverHistoryStack :: Functor f => f a -> HistoryStack f

-- | Cut off a <a>HistoryStack</a> to be at most the input deep
--   
--   We should have:
--   
--   <pre>
--   <a>historyStackDepth</a> (<a>cutoffHistoryStack</a> n xs) &lt;= n
--   </pre>
cutoffHistoryStack :: Functor f => Int -> HistoryStack f -> HistoryStack f

-- | Flatten a <a>HistoryStack</a> into a single layer
flattenHistoryStack :: Monad m => HistoryStack m -> m ()

-- | Get the depth of a <a>HistoryStack</a> while evaluating it a la
--   <a>flattenHistoryStack</a>
historyStackDepth :: Monad m => HistoryStack m -> m Int

-- | At each layer, attempt to <a>catchError</a> and return <a>Pure</a> if
--   one is caught. Otherwise, repeat all of the layers of the
--   <a>HistoryStack</a> indefinitely.
--   
--   Note: Since we've already caught any possible errors at each layer, no
--   layer of <tt>m</tt> in the resulting <tt><a>Free</a> m e</tt> is
--   <a>throwError</a>.
catchFreeHistoryStack :: MonadError e m => HistoryStack m -> Free m e

-- | A <a>HistoryStack</a> is isomorphic to the <a>Free</a> <a>Monad</a> of
--   a <a>Functor</a>, specialized to the unit type <tt>`()`</tt>.
--   
--   See <a>freeToHistoryStack</a> for the other half of the isomorphism.
historyStackToFree :: Functor m => HistoryStack m -> Free m ()

-- | The <a>Free</a> <a>Monad</a> of a <a>Functor</a>, specialized to the
--   unit type <tt>`()`</tt>, is isomorphic to a <a>HistoryStack</a>.
--   
--   See <a>historyStackToFree</a> for the other half of the isomorphism.
freeToHistoryStack :: Functor m => Free m a -> HistoryStack m
instance GHC.Classes.Eq (f (Data.History.Stack.HistoryStack f)) => GHC.Classes.Eq (Data.History.Stack.HistoryStack f)
instance GHC.Classes.Ord (f (Data.History.Stack.HistoryStack f)) => GHC.Classes.Ord (Data.History.Stack.HistoryStack f)
instance GHC.Show.Show (f (Data.History.Stack.HistoryStack f)) => GHC.Show.Show (Data.History.Stack.HistoryStack f)
instance GHC.Base.Functor f => GHC.Base.Semigroup (Data.History.Stack.HistoryStack f)
instance GHC.Base.Functor f => GHC.Base.Monoid (Data.History.Stack.HistoryStack f)

module Control.Monad.Trans.History

-- | Adds a history of all effects that can be fetched, run, and reset.
--   
--   Note: Only effects in <tt>m</tt> are stored in the history so updates
--   to the <a>HistoryStack</a> <a>StateT</a> variable will be ignored
--   during history replays.
--   
--   See <a>historyExample</a> and <a>historyExample2</a> for examples.
--   
--   See <a>MonadHistory</a> for a <a>MonadTrans</a>former type-class a la
--   <tt>mtl</tt>
newtype HistoryT m a
HistoryT :: StateT (HistoryStack m) m a -> HistoryT m a
[unHistoryT] :: HistoryT m a -> StateT (HistoryStack m) m a

-- | Run a <a>HistoryT</a> computation
runHistoryT :: Monad m => HistoryT m a -> m a

-- | Because <a>HistoryT</a> includes the <a>Functor</a> variable in both
--   the argument and result of the <a>StateT</a> <a>Monad</a>, we need
--   natural transformations to and from <tt>n</tt> to hoist <tt>m -&gt;
--   n</tt>
hoistHistoryT :: (Functor n, Functor m) => (forall x. m x -> n x) -> (forall y. n y -> m y) -> HistoryT m a -> HistoryT n a

-- | <a>Monad</a>s <tt>m</tt> that support the features provided by
--   <a>HistoryT</a>; namely: getting, lifting and resetting a
--   <a>HistoryStack</a> of effects in <tt>n</tt>.
--   
--   <a>MonadHistory</a> instances should satisfy:
--   
--   <pre>
--   <a>resetHistory</a> <a>&gt;&gt;</a> <a>getHistory</a> = <a>return</a> <a>mempty</a>
--   <a>resetHistory</a> <a>&gt;&gt;</a> <a>liftHistory</a> f <a>&gt;&gt;</a> <a>getHistory</a> = <a>resetHistory</a> <a>&gt;&gt;</a> <a>liftHistory</a> f <a>&gt;&gt;</a> <a>return</a> (<a>singletonHistoryStack</a> f)
--   <a>getHistory</a> <a>&gt;&gt;=</a> \h0 -&gt; <a>liftHistory</a> f <a>&gt;&gt;</a> <a>getHistory</a> <a>&gt;&gt;=</a> \h1 -&gt; (h0, h1) = <a>getHistory</a> <a>&gt;&gt;=</a> \h0 -&gt; <a>liftHistory</a> f <a>&gt;&gt;</a> <a>return</a> (h0, <a>pushHistory</a> f h0)
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>The second rule can be derived from the first and last.</li>
--   <li>Only effects in <tt>n</tt> are stored in the history</li>
--   </ul>
class (Monad m, Monad n) => MonadHistory m n | m -> n

-- | Get the current <a>HistoryStack</a>
getHistory :: MonadHistory m n => m (HistoryStack n)

-- | Lift the effect <a>Monad</a> to the outer <a>Monad</a>
liftHistory :: MonadHistory m n => n a -> m a

-- | Reset the <a>HistoryStack</a> to <a>mempty</a>
resetHistory :: MonadHistory m n => m ()

-- | Run a <a>HistoryStack</a>
runHistoryStack :: MonadHistory m n => HistoryStack n -> m ()

-- | Reset the <a>HistoryStack</a> before throwing the error
breakHistory :: (MonadHistory m n, MonadError e n) => e -> m a

-- | Example with <a>getHistory</a>, <a>runHistoryStack</a> and
--   <a>resetHistory</a>:
--   
--   <pre>
--   historyExample :: IO ()
--   historyExample = runHistoryT $ do
--     let p = liftIO . (print :: Int -&gt; IO ())
--         ps = liftIO . putStrLn
--     p 1
--     p 2
--     p 3
--     history1 &lt;- getHistory
--     ps "repeating history up to now"
--     runHistoryStack history1
--     ps "(nothing else is repeated)"
--   
--     ps ""
--     ps "Now we reset:"
--     resetHistory
--   
--     p 42
--     ps "^ it's a number"
--   
--     history2 &lt;- getHistory
--     ps "repeating history up to now"
--     runHistoryStack history2
--     ps "(nothing else is repeated)"
--   </pre>
--   
--   Results:
--   
--   <pre>
--   λ&gt; historyExample
--   1
--   2
--   3
--   repeating history up to now
--   1
--   2
--   3
--   (nothing else is repeated)
--   
--   Now we reset:
--   42
--   ^ it's a number
--   repeating history up to now
--   42
--   ^ it's a number
--   (nothing else is repeated)
--   </pre>
historyExample :: IO ()

-- | Simple example:
--   
--   <pre>
--   historyExample2 :: IO ()
--   historyExample2 =
--     runHistoryT $ do
--       liftIO $ putStrLn "repeat me 1"
--       liftIO $ putStrLn "repeat me 2"
--       liftIO $ putStrLn "repeat me 3"
--       history1 &lt;- getHistory
--       liftIO $ putStrLn "repeating:"
--       stackDepth &lt;- lift $ historyStackDepth history1
--       liftIO . putStrLn $ unwords [<a>Repeated</a>, show stackDepth, "layers of IO"]
--   </pre>
--   
--   Results:
--   
--   <pre>
--   λ&gt; historyExample2
--   repeat me 1
--   repeat me 2
--   repeat me 3
--   repeating:
--   repeat me 1
--   repeat me 2
--   repeat me 3
--   Repeated 3 layers of IO
--   </pre>
historyExample2 :: IO ()
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.History.HistoryT m)
instance GHC.Base.Monad m => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.History.HistoryT m) m
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Except.ExceptT e m) n
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Identity.IdentityT m) n
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Select.SelectT s m) n
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.State.Lazy.StateT s m) n
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.State.Strict.StateT s m) n
instance (Control.Monad.Trans.History.MonadHistory m n, GHC.Base.Monoid w) => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Writer.Lazy.WriterT w m) n
instance (Control.Monad.Trans.History.MonadHistory m n, GHC.Base.Monoid w) => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Writer.Strict.WriterT w m) n
instance (Control.Monad.Trans.History.MonadHistory m n, GHC.Base.Monoid w) => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Accum.AccumT w m) n
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Cont.ContT r m) n
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Reader.ReaderT r m) n
instance (Control.Monad.Trans.History.MonadHistory m n, GHC.Base.Monoid w) => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.RWS.Lazy.RWST r w s m) n
instance (Control.Monad.Trans.History.MonadHistory m n, GHC.Base.Monoid w) => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.RWS.Strict.RWST r w s m) n
instance Control.Monad.Trans.History.MonadHistory m n => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Maybe.MaybeT m) n
instance (Control.Monad.Trans.History.MonadHistory m n, GHC.Base.Functor f) => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.Free.FreeT f m) n
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Trans.History.HistoryT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.History.HistoryT m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Data.History.Stack.HistoryStack m) (Control.Monad.Trans.History.HistoryT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.History.HistoryT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.History.HistoryT m)

module Control.Monad.Trans.HisT

-- | Monad transformer that includes the history of effects that lead up to
--   the current value
newtype HisT m a
HisT :: StateT (m ()) m a -> HisT m a
[unHisT] :: HisT m a -> StateT (m ()) m a

-- | Run a <a>HisT</a> computation
evalHisT :: Monad m => HisT m a -> m a
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.HisT.HisT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Trans.HisT.HisT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.HisT.HisT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.HisT.HisT
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (m ()) (Control.Monad.Trans.HisT.HisT m)
instance GHC.Base.Monad m => Control.Monad.Trans.History.MonadHistory (Control.Monad.Trans.HisT.HisT m) m

module Control.Monad.Trans.Repeat
data RepeatF r a
[Repeat] :: (r -> a) -> RepeatF r a
[Break] :: r -> RepeatF r a
[Return] :: a -> RepeatF r a
newtype RepeatT r m a
RepeatT :: FreeT (RepeatF r) m a -> RepeatT r m a
[runRepeatT] :: RepeatT r m a -> FreeT (RepeatF r) m a

-- | <a>Nothing</a> iff it's <a>Repeat</a>, <a>Left</a> iff it's
--   <a>Break</a>
execRepeatT :: Monad m => RepeatT r m a -> ExceptT r (MaybeT m) a
breakM :: Monad m => r -> RepeatT r m a
repeatM :: Monad m => RepeatT r m r
test :: Int -> IO ()
data RepeaTF r a
[Brk] :: r -> RepeaTF r a
[Rep] :: (r -> a) -> RepeaTF r a
newtype RepeaT r m a
RepeaT :: FreeT (RepeaTF r) m a -> RepeaT r m a
[unRepeaT] :: RepeaT r m a -> FreeT (RepeaTF r) m a
eval :: Monad m => RepeaT r m a -> ExceptT (RepeaTF r a) m a
evalFT :: Monad m => FreeT (RepeaTF r) (HisT m) a -> ExceptT (RepeaTF r a) (HisT m) a

-- | <a>undefined</a>
evalF :: Monad m => FreeF (RepeaTF r) a (FreeT (RepeaTF r) (HisT m) a) -> ExceptT (RepeaTF r a) (HisT m) a

-- | <a>undefined</a>
evalTF :: Monad m => RepeaTF r (FreeT (RepeaTF r) (HisT m) a) -> HisT (ExceptT (RepeaTF r a) m) a

-- | Repeat the <a>Monad</a>ic action until an exception is thrown
fixLeft :: Monad m => ExceptT a m () -> m a
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Trans.Repeat.RepeaT r m)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Trans.Repeat.RepeatT r m)
instance GHC.Base.Functor (Control.Monad.Trans.Repeat.RepeatF r)
instance GHC.Base.Functor (Control.Monad.Trans.Repeat.RepeaTF r)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Trans.Repeat.RepeatT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Repeat.RepeatT r m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Repeat.RepeatT r)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Repeat.RepeatT r m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Repeat.RepeatT r m)
